> ## Задача 1
>
> Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).
>
> Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
>
> Вы как инженер поддержки решили произвести данную операцию:
>
> - напишите список операций, которые вы будете производить для остановки запроса пользователя
> - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB



Переходим в БД admin, только из-под неё можно просмотреть все сессии на сервере.
**use admin**

Выводим список сессий.
**db.aggregate( [ { $currentOp : { allUsers: true, localOps: true }}] )**
  или
**db.aggregate( [ { $currentOp : { allUsers: true, localOps: true }}] ).pretty()**

Думаю нужную сессию можно определить по параметрам "client":
И, наверное, отфильтровать по effectiveUsers:
**db.aggregate( [{ $currentOp : { allUsers: true, localOps: true }} ,  { $match : { effectiveUsers: [{user : "admin"}]}} ] )**

Определить opid, примерно будет выглядеть так: 
**"opid" : 147502 или  на shard-кластере: <shardName>:<opid on that shard>**

Завершить проблемную операцию: 
**db.killOp(<opId>)**

Пример как выглядит для shard-кластера: 
**db.killOp("shardB:79014");**

> 
>
> - предложите вариант решения     проблемы с долгими (зависающими) запросами в MongoDB



В том же разделе документации, можно установить предел по времени, после которого запросы будут завершаться, для данных запросов добавить данную настройку (maxTimeMS(время)).

Пример:

**db.location.find( { "town": { "$regex": "(Pine Lumber)",**  **"$options": 'i' } } ).maxTimeMS(30)**



> 
>
> ## Задача 2
>
> Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
>
> Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
>
> При масштабировании сервиса до N реплик вы увидели, что:
>
> - сначала рост отношения записанных значений к истекшим
> - Redis блокирует операции записи
>
> Как вы думаете, в чем может быть проблема?



В какой то момент отношения истекших ключей к имеющимся ключам превысило 25%, произошла блокировка методом очистки **«ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP»** пока он не сможет выполняя цикличную очистку добиться отношения просроченных к имеющимся ниже 25%.

 

Наверное, нужно увеличить значение параметра **ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP.**







> ## Задача 3
>
> Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).
>
> Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
>
> ```
> InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
> ```
>
> Как вы думаете, почему это начало происходить и как локализовать проблему?
>
> Какие пути решения данной проблемы вы можете предложить?



Из-за большого размера таблицы время выборки данных превышает значение net_read_timeout (по умолчанию 30 секунд).

Можно увеличить **net_read_timeout до 60 секунд** и включить **slow_log на 30 секунд.**

Для расширенной диагностики (если причина не подтвердилась) можно запустить mysql с большей детализацией лога, например с --log-warnings = 2.

 

Как решение это шардирование\секционирование таблицы (как горизонтальное так и вертикальное), скорее всего с использованием индексов в R-деревьях







> ## Задача 4
>
> Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.
>
> Вы решили перевезти гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
>
> После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
>
> ```
> postmaster invoked oom-killer
> ```
>
> Как вы думаете, что происходит?
>
> Как бы вы решили данную проблему?





Экземпляру не хватает RAM для работы.

Самое банальное это предоставить машине больше RAM.

 

Дальше все зависит от того сколько памяти на сервере (может её вполне достаточно..).

 

Проверить ОС, вдруг она 32-битная, и не смотря на выделенную память, может пользоваться меньшим её количеством.

 

Нужно начать мониторить сколько RAM выделяется процессу Postgres,  Если нет возможности добавить RAM

и мы готовы мириться с падением производительности то добавить SWAP.

 

Проверить параметры, затрагивающие память в Postgres.

max_connections не должен быть установлен выше, чем необходимо.

shared_buffer (не завышен ли), Рекомендуемое значение составляет 25% от наличия ОЗУ.

work_mem (не завышен ли, если много пользователей, то может съесть много памяти) и т.д.

 

Провести трассировку основных запросов, возможно неоптимально написан запрос (нужно его доработать), он и съедает всю оперативную память. 





