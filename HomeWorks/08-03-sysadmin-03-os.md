# Домашнее задание к занятию "3.3. Операционные системы"

>1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`.  


chdir("/tmp")  

>2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:  
    ```bash  
    vagrant@netology1:~$ file /dev/tty  
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda  
    /dev/sda: block special (8/0)  
    vagrant@netology1:~$ file /bin/bash  
    /bin/bash: ELF 64-bit LSB shared object, x86-64  
    ```  
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки. 
    
 
strace -xf -e openat -o traceout.log file /dev/sda  
и  
sotruss file /dev/sda 2>&1  

Из найденного: /usr/share/misc/magic.mgc – содержит шаблоны на что похожи бинарные файлы, которые использует file.  
   
    
>3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).  

Находим файл.  
**#lsof | grep test_del_file**  
python3   66685              root    3r      REG                8,5       29    2373745 /root/test_del_file (deleted)  
И затираем информацию в дескрипторе:  
echo  >  /proc/66685/fd/3  



>4. Занимают ли зомби-процессы какое-то ресурсы в ОС (CPU, RAM, IO)?  


Нет, ресурсы освобождаются. Занимает только запись в таблице процессов.   


>5. В iovisor BCC есть утилита `opensnoop`. На какие файлы вы увидели вызов `open` за первую секунду работы утилиты?   

При каждом вызове разные, пример:   
**#opensnoop-bpfcc**  
_/etc/mtab  
/proc/devices  
/run/systemd/resolve/resolv.conf  
/proc/net/route  
/proc/net/ipv6_route 
/proc/uptime_  



>6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.   


uname({sysname="Linux", nodename="ubuntu20", ...}) = 0  
Используется системный вызов «uname»   
man 2 uname     
Цитата: Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.    



>7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:  
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```

    
    
; - Все команды выполняются независимо от статуса возврата предыдущей команды;  
&& - следующая команда выполняется только при успешном выполнении предыдущей.

>    Есть ли смысл использовать в bash `&&`, если применить `set -e`?  

Думаю, нет смысла, так как при параметре -e команда завершит работу shell после первой ошибке в составном списке команд.      
    
    
    
>8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?
  
  
-e завершить работу после появлении не нулевого кода команды  
-u неустановленные переменные трактуются как ошибки  
-x в стандартный поток ошибок пишется трассировка по каждой команде до её выполнения (с какими аргументами вызвана) и в процессе   
-o pipefail если в ряде команд в pipe будет ненулевое значение, то как результат конвейера вернется этот последний ненулевой код.  
  
Мои предположения. Сценарий в таком случае может не иметь обработчика ошибок (не нужно о нем думать) и не будет продолжать работу при первом появлении ошибки (так как дальнейшая его работа скорее всего будет некорректной). А если вывод сценария перенаправить в файл, то будет необходимая информация для анализа и устранения ошибки (не нужно писать дополнительного вывода в протокол).  


>9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).  


Наиболее часто встречающийся:  S – Спящий, ожидает завершения события.  
< - высокий приоритет  
N – низкий приоритет   
s – лидер в сессии (процесс, в котором идентификатор сеанса и группы == идентификатору процесса, это процесс лидер этой группы, создавший её, механизм как я понял применяется например для возможности управления группой процессов вне зависимости от наследования, например закрытия группы процессов при закрытии сессии)  
l – является многопоточным  
+ - находится в foreground  



>10. Можно ли по выводу `dmesg` понять, осознает ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?

Можно:  
dmesg | grep -i virtual  
[    0.000000] DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006  
[    0.000000] CPU MTRRs all blank - virtualized system….   



>11. Как настроен sysctl `fs.nr_open` на системе по-умолчанию? Узнайте, что означает этот параметр. Какой другой существующий лимит не позволит достичь такого числа (`man ulimit`)?  

fs.nr_open = 1048576 – системное ограничение на количество открытых дескрипторов.  
ulimit -n        the maximum number of open file descriptors,  мягкий лимит для пользователя =  1024  
, а жесткое можно посмотреть ulimit -Hn.  



>12. Запустите любой долгоживущий процесс (не `ls`, который отработает мгновенно, а, например, `sleep 1h`) в отдельном неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через `nsenter`. Для простоты работайте в данном задании под root (`sudo -i`). Под обычным пользователем требуются дополнительные опции (`--map-root-user`) и т.д.  

**#unshare -f --pid --mount-proc sleep 1h**   
**#lsns**  
_4026532574 mnt         2  1834 root             unshare -f --pid --mount-proc sleep 1h    
4026532575 pid         1  1835 root             sleep 1h_    

**#nsenter --target 1835 --pid –mount**    

**#ps aux**
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND  
root           1  0.0  0.0  16708   584 pts/0    S+   20:19   0:00 sleep 1h  
root           2  0.0  0.1  19500  5144 pts/1    S    20:21   0:00 -bash  
root          11  0.0  0.0  20108  3380 pts/1    R+   20:21   0:00 ps aux  


>[Не сделано]13. Найдите информацию о том, что такое `:(){ :|:& };:`. Запустите эту команду в своей виртуальной машине Vagrant с Ubuntu 20.04 (**это важно, поведение в других ОС не проверялось**). Некоторое время все будет "плохо", после чего (минуты) – ОС должна стабилизироваться. Вызов `dmesg` расскажет, какой механизм помог автоматической стабилизации. Как настроен этот механизм по-умолчанию, и как изменить число процессов, которое можно создать в сессии?

:(){ :|:& };:  - это Fork Bomb — коварная маленькая программа, которая порождает себя n-раз, отбросив цепную реакцию (рекурсия) и тем самым быстро исчерпав ресурсы системы.  
Где:  
:() — Определение функции.  
{  — Открытие функции.  
:|: — Далее, загружает копию функции «:» в память тем самым, будет вызывать само себя с использованием техники программирования (так называемая рекурсия) и передает результат на другой вызов функции.  
‘:’ — Худшая часть — функция, вызываемая два раза, чтобы «бомбить» вашу систему.  
& — Помещает вызов функции в фоновом режиме, чтобы fork (дочерний процесс) не мог «умереть» вообще, тем самым это начнет есть системные ресурсы.  
} — Закрытие функции.  
; — Завершите определение функции. Т.е является разделителем команд, (такой как и &&).  
: — Запускает функцию которая порождает fork bomb().  

[ 5523.598300] cgroup: fork rejected by pids controller in /user.slice/user-0.slice/session-3.scope  
[ 5557.049793] cgroup: fork rejected by pids controller in /user.slice/user-0.slice/user@0.service  


Срабатывает ограничение на количество pid для пользователя:   
**#cat /sys/fs/cgroup/pids/user.slice/user-0.slice**  
10172   

Для пользователей изменить /etc/security/limits.conf, например  
  _*                soft    nproc           20000_  
  _*                hard    nproc           21000_



Для root пока смотрю в сторону 
/etc/sysctl.conf  

?? /sys/fs/cgroup/pids/user.slice/user-0.slice/session-3.scope/pids.max  




>14. [не связано с материалом лекции 3.3, дополнение после лекции 3.2] При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:
    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```
	Почитайте, почему так происходит, и как изменить поведение.   
	
SSH может работать в 2 режимах - принимает идентификатор пользователя, и если передана команды, ssh выполняет переданные команды, например 'tty', при это оболочка на удаленной машине не предоставляется, если псевдо-терминал не назначен, то сеанс может в дальнейшем использоваться для передачи бинарных файлов (предполагаю на этом основана, например передача через SCP и возможно SFTP).    
Во втором случае, без передачи команды – сразу назначается псевдо-терминал, и пользователь может работать в нем.  
Если необходим псевдо-терминал для выполнения команды используется ключ -t:  
**#ssh -t localhost tty**  

	
	  

>15 [не связано с материалом лекции 3.3, дополнение после лекции 3.2] Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`.    


pgrep mc  
44264  
~$ sudo reptyr 44264  
Получилось отобрать у root mc и начать им пользоваться.  
